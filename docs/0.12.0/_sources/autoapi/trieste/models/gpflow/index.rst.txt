:py:mod:`trieste.models.gpflow`
===============================

.. py:module:: trieste.models.gpflow

.. autoapi-nested-parse::

   This package contains the primary interface for Gaussian process models. It also contains a
   number of :class:`TrainableProbabilisticModel` wrappers for GPflow-based models.



Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   builders/index.rst
   inducing_point_selectors/index.rst
   optimizer/index.rst
   sampler/index.rst


Package Contents
----------------

.. py:function:: build_gpr(data: trieste.data.Dataset, search_space: trieste.space.SearchSpace, kernel_priors: bool = True, likelihood_variance: Optional[float] = None, trainable_likelihood: bool = False) -> gpflow.models.GPR

   Build a :class:`~gpflow.models.GPR` model with sensible initial parameters and
   priors. We use :class:`~gpflow.kernels.Matern52` kernel and
   :class:`~gpflow.mean_functions.Constant` mean function in the model. We found the default
   configuration used here to work well in most situation, but it should not be taken as a
   universally good solution.

   We set priors for kernel hyperparameters by default in order to stabilize model fitting. We
   found the priors below to be highly effective for objective functions defined over the unit
   hypercube. They do seem to work for other search space sizes, but we advise caution when using
   them in such search spaces. Using priors allows for using maximum a posteriori estimate of
   these kernel parameters during model fitting.

   Note that although we scale parameters as a function of the size of the search space, ideally
   inputs should be normalised to the unit hypercube before building a model.

   :param data: Dataset from the initial design, used for estimating the variance of observations.
   :param search_space: Search space for performing Bayesian optimization, used for scaling the
       parameters.
   :param kernel_priors: If set to `True` (default) priors are set for kernel parameters (variance
       and lengthscale).
   :param likelihood_variance: Likelihood (noise) variance parameter can be optionally set to a
       certain value. If left unspecified (default), the noise variance is set to maintain the
       signal to noise ratio of value given by ``SIGNAL_NOISE_RATIO_LIKELIHOOD``, where signal
       variance in the kernel is set to the empirical variance.
   :param trainable_likelihood: If set to `True` Gaussian likelihood parameter is set to
       non-trainable. By default set to `False`.
   :return: A :class:`~gpflow.models.GPR` model.


.. py:function:: build_sgpr(data: trieste.data.Dataset, search_space: trieste.space.SearchSpace, kernel_priors: bool = True, likelihood_variance: Optional[float] = None, trainable_likelihood: bool = False, num_inducing_points: Optional[int] = None, trainable_inducing_points: bool = False) -> gpflow.models.SGPR

   Build a :class:`~gpflow.models.SGPR` model with sensible initial parameters and
   priors. We use :class:`~gpflow.kernels.Matern52` kernel and
   :class:`~gpflow.mean_functions.Constant` mean function in the model. We found the default
   configuration used here to work well in most situation, but it should not be taken as a
   universally good solution.

   We set priors for kernel hyperparameters by default in order to stabilize model fitting. We
   found the priors below to be highly effective for objective functions defined over the unit
   hypercube. They do seem to work for other search space sizes, but we advise caution when using
   them in such search spaces. Using priors allows for using maximum a posteriori estimate of
   these kernel parameters during model fitting.

   For performance reasons number of inducing points should not be changed during Bayesian
   optimization. Hence, even if the initial dataset is smaller, we advise setting this to a higher
   number. By default inducing points are set to Sobol samples for the continuous search space,
   and simple random samples for discrete or mixed search spaces. This carries
   the risk that optimization gets stuck if they are not trainable, which calls for adaptive
   inducing point selection during the optimization. This functionality will be added to Trieste
   in future.

   Note that although we scale parameters as a function of the size of the search space, ideally
   inputs should be normalised to the unit hypercube before building a model.

   :param data: Dataset from the initial design, used for estimating the variance of observations.
   :param search_space: Search space for performing Bayesian optimization, used for scaling the
       parameters.
   :param kernel_priors: If set to `True` (default) priors are set for kernel parameters (variance
       and lengthscale).
   :param likelihood_variance: Likelihood (noise) variance parameter can be optionally set to a
       certain value. If left unspecified (default), the noise variance is set to maintain the
       signal to noise ratio of value given by ``SIGNAL_NOISE_RATIO_LIKELIHOOD``, where signal
       variance in the kernel is set to the empirical variance.
   :param trainable_likelihood: If set to `True` Gaussian likelihood parameter is set to
       be trainable. By default set to `False`.
   :param num_inducing_points: The number of inducing points can be optionally set to a
       certain value. If left unspecified (default), this number is set to either
       ``NUM_INDUCING_POINTS_PER_DIM``*dimensionality of the search space or value given by
       ``MAX_NUM_INDUCING_POINTS``, whichever is smaller.
   :param trainable_inducing_points: If set to `True` inducing points will be set to
       be trainable. This option should be used with caution. By default set to `False`.
   :return: An :class:`~gpflow.models.SGPR` model.


.. py:function:: build_svgp(data: trieste.data.Dataset, search_space: trieste.space.SearchSpace, classification: bool = False, kernel_priors: bool = True, likelihood_variance: Optional[float] = None, trainable_likelihood: bool = False, num_inducing_points: Optional[int] = None, trainable_inducing_points: bool = False) -> gpflow.models.SVGP

   Build a :class:`~gpflow.models.SVGP` model with sensible initial parameters and
   priors. Both regression and binary classification models are
   available. We use :class:`~gpflow.kernels.Matern52` kernel and
   :class:`~gpflow.mean_functions.Constant` mean function in the model. We found the default
   configuration used here to work well in most situation, but it should not be taken as a
   universally good solution.

   We set priors for kernel hyperparameters by default in order to stabilize model fitting. We
   found the priors below to be highly effective for objective functions defined over the unit
   hypercube. They do seem to work for other search space sizes, but we advise caution when using
   them in such search spaces. Using priors allows for using maximum a posteriori estimate of
   these kernel parameters during model fitting.

   For performance reasons number of inducing points should not be changed during Bayesian
   optimization. Hence, even if the initial dataset is smaller, we advise setting this to a higher
   number. By default inducing points are set to Sobol samples for the continuous search space,
   and simple random samples for discrete or mixed search spaces. This carries
   the risk that optimization gets stuck if they are not trainable, which calls for adaptive
   inducing point selection during the optimization. This functionality will be added to Trieste
   in future.

   Note that although we scale parameters as a function of the size of the search space, ideally
   inputs should be normalised to the unit hypercube before building a model.

   :param data: Dataset from the initial design, used for estimating the variance of observations.
   :param search_space: Search space for performing Bayesian optimization, used for scaling the
       parameters.
   :param classification: If a classification model is needed, this should be set to `True`, in
       which case a Bernoulli likelihood will be used. If a regression model is required, this
       should be set to `False` (default), in which case a Gaussian likelihood is used.
   :param kernel_priors: If set to `True` (default) priors are set for kernel parameters (variance
       and lengthscale).
   :param likelihood_variance: Likelihood (noise) variance parameter can be optionally set to a
       certain value. If left unspecified (default), the noise variance is set to maintain the
       signal to noise ratio of value given by ``SIGNAL_NOISE_RATIO_LIKELIHOOD``, where signal
       variance in the kernel is set to the empirical variance. This argument is ignored in the
       classification case.
   :param trainable_likelihood: If set to `True` likelihood parameter is set to
       be trainable. By default set to `False`. This argument is ignored in the classification
       case.
   :param num_inducing_points: The number of inducing points can be optionally set to a
       certain value. If left unspecified (default), this number is set to either
       ``NUM_INDUCING_POINTS_PER_DIM``*dimensionality of the search space or value given by
       ``MAX_NUM_INDUCING_POINTS``, whichever is smaller.
   :param trainable_inducing_points: If set to `True` inducing points will be set to
       be trainable. This option should be used with caution. By default set to `False`.
   :return: An :class:`~gpflow.models.SVGP` model.


.. py:function:: build_vgp_classifier(data: trieste.data.Dataset, search_space: trieste.space.SearchSpace, kernel_priors: bool = True, noise_free: bool = False, kernel_variance: Optional[float] = None) -> gpflow.models.VGP

   Build a :class:`~gpflow.models.VGP` binary classification model with sensible initial
   parameters and priors. We use :class:`~gpflow.kernels.Matern52` kernel and
   :class:`~gpflow.mean_functions.Constant` mean function in the model. We found the default
   configuration used here to work well in most situation, but it should not be taken as a
   universally good solution.

   We set priors for kernel hyperparameters by default in order to stabilize model fitting. We
   found the priors below to be highly effective for objective functions defined over the unit
   hypercube. They do seem to work for other search space sizes, but we advise caution when using
   them in such search spaces. Using priors allows for using maximum a posteriori estimate of
   these kernel parameters during model fitting. In the ``noise_free`` case we do not use prior
   for the kernel variance parameters.

   Note that although we scale parameters as a function of the size of the search space, ideally
   inputs should be normalised to the unit hypercube before building a model.

   :param data: Dataset from the initial design, used for estimating the variance of observations.
   :param search_space: Search space for performing Bayesian optimization, used for scaling the
       parameters.
   :param kernel_priors: If set to `True` (default) priors are set for kernel parameters (variance
       and lengthscale). In the ``noise_free`` case kernel variance prior is not set.
   :param noise_free: If  there is a prior information that the classification problem is a
       deterministic one, this should be set to `True` and kernel variance will be fixed to a
       higher default value ``CLASSIFICATION_KERNEL_VARIANCE_NOISE_FREE`` leading to sharper
       classification boundary. In this case prior for the kernel variance parameter is also not
       set. By default set to `False`.
   :param kernel_variance: Kernel variance parameter can be optionally set to a
       certain value. If left unspecified (default), the kernel variance is set to
       ``CLASSIFICATION_KERNEL_VARIANCE_NOISE_FREE`` in the ``noise_free`` case and to
       ``CLASSIFICATION_KERNEL_VARIANCE`` otherwise.
   :return: A :class:`~gpflow.models.VGP` model.


.. py:class:: InducingPointSelector(search_space: trieste.space.SearchSpace, recalc_every_model_update: bool = True)

   Bases: :py:obj:`abc.ABC`, :py:obj:`Generic`\ [\ :py:obj:`trieste.models.interfaces.ProbabilisticModelType`\ ]

   This class provides functionality to update the inducing points of an inducing point-based model
   as the Bayesian optimization progresses.

   The only constraint on subclasses of :class:`InducingPointSelector` is that they preserve
   the shape of the inducing points so not to trigger expensive retracing.

   It can often be beneficial to change the inducing points during optimization, for example
   to allow the model to focus its limited modelling resources into promising areas of the space.
   See :cite:`vakili2021scalable` for demonstrations of some of
   our :class:`InducingPointSelectors`.

   :param search_space: The global search space over which the optimization is defined.
   :param recalc_every_model_update: If True then recalculate the inducing points for each
       model update, otherwise just recalculate on the first call.

   .. py:method:: calculate_inducing_points(self, current_inducing_points: trieste.types.TensorType, model: trieste.models.interfaces.ProbabilisticModelType, dataset: trieste.data.Dataset) -> trieste.types.TensorType

      Calculate the new inducing points given the existing inducing points.

      If `recalc_every_model_update` is set to False then we only generate new inducing points
      for the first :meth:`calculate_inducing_points` call, otherwise we just return the current
      inducing points.

      :param current_inducing_points: The current inducing points used by the model.
      :param model: The sparse model.
      :param dataset: The data from the observer.
      :return: The new updated inducing points.
      :raise NotImplementedError: If model has more than one set of inducing variables.


   .. py:method:: _recalculate_inducing_points(self, M: int, model: trieste.models.interfaces.ProbabilisticModelType, dataset: trieste.data.Dataset) -> trieste.types.TensorType
      :abstractmethod:

      Method for calculating new inducing points given a `model` and `dataset`.

      This method is to be implemented by all subclasses of :class:`InducingPointSelector`.

      :param M: Desired number of inducing points.
      :param model: The sparse model.
      :param dataset: The data from the observer.
      :return: The new updated inducing points.



.. py:class:: KMeansInducingPointSelector(search_space: trieste.space.SearchSpace, recalc_every_model_update: bool = True)

   Bases: :py:obj:`InducingPointSelector`\ [\ :py:obj:`trieste.models.interfaces.ProbabilisticModel`\ ]

   An :class:`InducingPointSelector` that chooses points as centroids of a K-means clustering
   of the training data.

   :param search_space: The global search space over which the optimization is defined.
   :param recalc_every_model_update: If True then recalculate the inducing points for each
       model update, otherwise just recalculate on the first call.

   .. py:method:: _recalculate_inducing_points(self, M: int, model: trieste.models.interfaces.ProbabilisticModel, dataset: trieste.data.Dataset) -> trieste.types.TensorType

      Calculate `M` centroids from a K-means clustering of the training data.

      If the clustering returns fewer than `M` centroids or if we have fewer than `M` training
      data, then we fill the remaining points with random samples across the search space.

      :param M: Desired number of inducing points.
      :param model: The sparse model.
      :param dataset: The data from the observer. Must be populated.
      :return: The new updated inducing points.
      :raise tf.errors.InvalidArgumentError: If ``dataset`` is empty.



.. py:class:: RandomSubSampleInducingPointSelector(search_space: trieste.space.SearchSpace, recalc_every_model_update: bool = True)

   Bases: :py:obj:`InducingPointSelector`\ [\ :py:obj:`trieste.models.interfaces.ProbabilisticModel`\ ]

   An :class:`InducingPointSelector` that chooses points at random from the training data.

   :param search_space: The global search space over which the optimization is defined.
   :param recalc_every_model_update: If True then recalculate the inducing points for each
       model update, otherwise just recalculate on the first call.

   .. py:method:: _recalculate_inducing_points(self, M: int, model: trieste.models.interfaces.ProbabilisticModel, dataset: trieste.data.Dataset) -> trieste.types.TensorType

      Sample `M` points from the training data without replacement. If we require more
      inducing points than training data, then we fill the remaining points with random
      samples across the search space.

      :param M: Desired number of inducing points.
      :param model: The sparse model.
      :param dataset: The data from the observer. Must be populated.
      :return: The new updated inducing points.
      :raise tf.errors.InvalidArgumentError: If ``dataset`` is empty.



.. py:class:: UniformInducingPointSelector(search_space: trieste.space.SearchSpace, recalc_every_model_update: bool = True)

   Bases: :py:obj:`InducingPointSelector`\ [\ :py:obj:`trieste.models.interfaces.ProbabilisticModel`\ ]

   An :class:`InducingPointSelector` that chooses points sampled uniformly across the search space.

   :param search_space: The global search space over which the optimization is defined.
   :param recalc_every_model_update: If True then recalculate the inducing points for each
       model update, otherwise just recalculate on the first call.

   .. py:method:: _recalculate_inducing_points(self, M: int, model: trieste.models.interfaces.ProbabilisticModel, dataset: trieste.data.Dataset) -> trieste.types.TensorType

      Sample `M` points. If `search_space` is a :class:`Box` then we use a space-filling Sobol
      design to ensure high diversity.

      :param M: Desired number of inducing points.
      :param model: The sparse model .
      :param dataset: The data from the observer.
      :return: The new updated inducing points.



.. py:class:: GPflowPredictor(optimizer: Optimizer | None = None)

   Bases: :py:obj:`trieste.models.interfaces.SupportsPredictJoint`, :py:obj:`trieste.models.interfaces.SupportsGetKernel`, :py:obj:`trieste.models.interfaces.SupportsGetObservationNoise`, :py:obj:`trieste.models.interfaces.HasReparamSampler`, :py:obj:`abc.ABC`

   A trainable wrapper for a GPflow Gaussian process model.

   :param optimizer: The optimizer with which to train the model. Defaults to
       :class:`~trieste.models.optimizer.Optimizer` with :class:`~gpflow.optimizers.Scipy`.

   .. py:method:: optimizer(self) -> trieste.models.optimizer.Optimizer
      :property:

      The optimizer with which to train the model.


   .. py:method:: create_posterior_cache(self) -> None

      Create a posterior cache for fast sequential predictions.  Note that this must happen
      at initialisation and *after* we ensure the model data is variable. Furthermore,
      the cache must be updated whenever the underlying model is changed.


   .. py:method:: update_posterior_cache(self) -> None

      Update the posterior cache. This needs to be called whenever the underlying model
      is changed.


   .. py:method:: model(self) -> gpflow.models.GPModel
      :property:

      The underlying GPflow model.


   .. py:method:: predict(self, query_points: trieste.types.TensorType) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Return the mean and variance of the independent marginal distributions at each point in
      ``query_points``.

      This is essentially a convenience method for :meth:`predict_joint`, where non-event
      dimensions of ``query_points`` are all interpreted as broadcasting dimensions instead of
      batch dimensions, and the covariance is squeezed to remove redundant nesting.

      :param query_points: The points at which to make predictions, of shape [..., D].
      :return: The mean and variance of the independent marginal distributions at each point in
          ``query_points``. For a predictive distribution with event shape E, the mean and
          variance will both have shape [...] + E.


   .. py:method:: predict_joint(self, query_points: trieste.types.TensorType) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      :param query_points: The points at which to make predictions, of shape [..., B, D].
      :return: The mean and covariance of the joint marginal distribution at each batch of points
          in ``query_points``. For a predictive distribution with event shape E, the mean will
          have shape [..., B] + E, and the covariance shape [...] + E + [B, B].


   .. py:method:: sample(self, query_points: trieste.types.TensorType, num_samples: int) -> trieste.types.TensorType

      Return ``num_samples`` samples from the independent marginal distributions at
      ``query_points``.

      :param query_points: The points at which to sample, with shape [..., N, D].
      :param num_samples: The number of samples at each point.
      :return: The samples. For a predictive distribution with event shape E, this has shape
          [..., S, N] + E, where S is the number of samples.


   .. py:method:: predict_y(self, query_points: trieste.types.TensorType) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Return the mean and variance of the independent marginal distributions at each point in
      ``query_points`` for the observations, including noise contributions.

      Note that this is not supported by all models.

      :param query_points: The points at which to make predictions, of shape [..., D].
      :return: The mean and variance of the independent marginal distributions at each point in
          ``query_points``. For a predictive distribution with event shape E, the mean and
          variance will both have shape [...] + E.


   .. py:method:: get_kernel(self) -> gpflow.kernels.Kernel

      Return the kernel of the model.

      :return: The kernel.


   .. py:method:: get_mean_function(self) -> gpflow.mean_functions.MeanFunction

      Return the mean function of the model.

      :return: The mean function.


   .. py:method:: get_observation_noise(self) -> trieste.types.TensorType

      Return the variance of observation noise for homoscedastic likelihoods.

      :return: The observation noise.
      :raise NotImplementedError: If the model does not have a homoscedastic likelihood.


   .. py:method:: optimize(self, dataset: trieste.data.Dataset) -> None

      Optimize the model with the specified `dataset`.

      :param dataset: The data with which to optimize the `model`.


   .. py:method:: log(self) -> None

      Log model-specific information at a given optimization step.


   .. py:method:: reparam_sampler(self, num_samples: int) -> trieste.models.interfaces.ReparametrizationSampler[GPflowPredictor]

      Return a reparametrization sampler providing `num_samples` samples.

      :return: The reparametrization sampler.



.. py:class:: GaussianProcessRegression(model: gpflow.models.GPR, optimizer: Optimizer | None = None, num_kernel_samples: int = 10, num_rff_features: int = 1000, use_decoupled_sampler: bool = True)

   Bases: :py:obj:`trieste.models.gpflow.interface.GPflowPredictor`, :py:obj:`trieste.models.interfaces.TrainableProbabilisticModel`, :py:obj:`trieste.models.interfaces.FastUpdateModel`, :py:obj:`trieste.models.gpflow.interface.SupportsCovarianceBetweenPoints`, :py:obj:`trieste.models.interfaces.SupportsGetInternalData`, :py:obj:`trieste.models.interfaces.HasTrajectorySampler`

   A :class:`TrainableProbabilisticModel` wrapper for a GPflow :class:`~gpflow.models.GPR`.

   As Bayesian optimization requires a large number of sequential predictions (i.e. when maximizing
   acquisition functions), rather than calling the model directly at prediction time we instead
   call the posterior objects built by these models. These posterior objects store the
   pre-computed Gram matrices, which can be reused to allow faster subsequent predictions. However,
   note that these posterior objects need to be updated whenever the underlying model is changed
   by calling :meth:`update_posterior_cache` (this
   happens automatically after calls to :meth:`update` or :math:`optimize`).

   :param model: The GPflow model to wrap.
   :param optimizer: The optimizer with which to train the model. Defaults to
       :class:`~trieste.models.optimizer.Optimizer` with :class:`~gpflow.optimizers.Scipy`.
   :param num_kernel_samples: Number of randomly sampled kernels (for each kernel parameter) to
       evaluate before beginning model optimization. Therefore, for a kernel with `p`
       (vector-valued) parameters, we evaluate `p * num_kernel_samples` kernels.
   :param num_rff_features: The number of random Fourier features used to approximate the
       kernel when calling :meth:`trajectory_sampler`. We use a default of 1000 as it
       typically perfoms well for a wide range of kernels. Note that very smooth
       kernels (e.g. RBF) can be well-approximated with fewer features.
   :param use_decoupled_sampler: If True use a decoupled random Fourier feature sampler, else
       just use a random Fourier feature sampler. The decoupled sampler suffers less from
       overestimating variance and can typically get away with a lower num_rff_features.

   .. py:method:: model(self) -> gpflow.models.GPR
      :property:

      The underlying GPflow model.


   .. py:method:: predict_y(self, query_points: trieste.types.TensorType) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Return the mean and variance of the independent marginal distributions at each point in
      ``query_points`` for the observations, including noise contributions.

      Note that this is not supported by all models.

      :param query_points: The points at which to make predictions, of shape [..., D].
      :return: The mean and variance of the independent marginal distributions at each point in
          ``query_points``. For a predictive distribution with event shape E, the mean and
          variance will both have shape [...] + E.


   .. py:method:: update(self, dataset: trieste.data.Dataset) -> None

      Update the model given the specified ``dataset``. Does not train the model.

      :param dataset: The data with which to update the model.


   .. py:method:: covariance_between_points(self, query_points_1: trieste.types.TensorType, query_points_2: trieste.types.TensorType) -> trieste.types.TensorType

      Compute the posterior covariance between sets of query points.

      .. math:: \Sigma_{12} = K_{12} - K_{x1}(K_{xx} + \sigma^2 I)^{-1}K_{x2}

      Note that query_points_2 must be a rank 2 tensor, but query_points_1 can
      have leading dimensions.

      :param query_points_1: Set of query points with shape [..., N, D]
      :param query_points_2: Sets of query points with shape [M, D]
      :return: Covariance matrix between the sets of query points with shape [..., L, N, M]
          (L being the number of latent GPs = number of output dimensions)


   .. py:method:: optimize(self, dataset: trieste.data.Dataset) -> None

      Optimize the model with the specified `dataset`.

      For :class:`GaussianProcessRegression`, we (optionally) try multiple randomly sampled
      kernel parameter configurations as well as the configuration specified when initializing
      the kernel. The best configuration is used as the starting point for model optimization.

      For trainable parameters constrained to lie in a finite interval (through a sigmoid
      bijector), we begin model optimization from the best of a random sample from these
      parameters' acceptable domains.

      For trainable parameters without constraints but with priors, we begin model optimization
      from the best of a random sample from these parameters' priors.

      For trainable parameters with neither priors nor constraints, we begin optimization from
      their initial values.

      :param dataset: The data with which to optimize the `model`.


   .. py:method:: find_best_model_initialization(self, num_kernel_samples: int) -> None

      Test `num_kernel_samples` models with sampled kernel parameters. The model's kernel
      parameters are then set to the sample achieving maximal likelihood.

      :param num_kernel_samples: Number of randomly sampled kernels to evaluate.


   .. py:method:: trajectory_sampler(self) -> trieste.models.interfaces.TrajectorySampler[GaussianProcessRegression]

      Return a trajectory sampler. For :class:`GaussianProcessRegression`, we build
      trajectories using a random Fourier feature approximation.

      At the moment only models with single latent GP are supported.

      :return: The trajectory sampler.
      :raise NotImplementedError: If we try to use the
          sampler with a model that has more than one latent GP.


   .. py:method:: get_internal_data(self) -> trieste.data.Dataset

      Return the model's training data.

      :return: The model's training data.


   .. py:method:: conditional_predict_f(self, query_points: trieste.types.TensorType, additional_data: trieste.data.Dataset) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Returns the marginal GP distribution at query_points conditioned on both the model
      and some additional data, using exact formula. See :cite:`chevalier2014corrected`
      (eqs. 8-10) for details.

      :param query_points: Set of query points with shape [M, D]
      :param additional_data: Dataset with query_points with shape [..., N, D] and observations
               with shape [..., N, L]
      :return: mean_qp_new: predictive mean at query_points, with shape [..., M, L],
               and var_qp_new: predictive variance at query_points, with shape [..., M, L]


   .. py:method:: conditional_predict_joint(self, query_points: trieste.types.TensorType, additional_data: trieste.data.Dataset) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Predicts the joint GP distribution at query_points conditioned on both the model
      and some additional data, using exact formula. See :cite:`chevalier2014corrected`
      (eqs. 8-10) for details.

      :param query_points: Set of query points with shape [M, D]
      :param additional_data: Dataset with query_points with shape [..., N, D] and observations
               with shape [..., N, L]
      :return: mean_qp_new: predictive mean at query_points, with shape [..., M, L],
               and cov_qp_new: predictive covariance between query_points, with shape
               [..., L, M, M]


   .. py:method:: conditional_predict_f_sample(self, query_points: trieste.types.TensorType, additional_data: trieste.data.Dataset, num_samples: int) -> trieste.types.TensorType

      Generates samples of the GP at query_points conditioned on both the model
      and some additional data.

      :param query_points: Set of query points with shape [M, D]
      :param additional_data: Dataset with query_points with shape [..., N, D] and observations
               with shape [..., N, L]
      :param num_samples: number of samples
      :return: samples of f at query points, with shape [..., num_samples, M, L]


   .. py:method:: conditional_predict_y(self, query_points: trieste.types.TensorType, additional_data: trieste.data.Dataset) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Generates samples of y from the GP at query_points conditioned on both the model
      and some additional data.

      :param query_points: Set of query points with shape [M, D]
      :param additional_data: Dataset with query_points with shape [..., N, D] and observations
               with shape [..., N, L]
      :return: predictive variance at query_points, with shape [..., M, L],
               and predictive variance at query_points, with shape [..., M, L]



.. py:class:: SparseGaussianProcessRegression(model: gpflow.models.SGPR, optimizer: Optimizer | None = None, num_rff_features: int = 1000, inducing_point_selector: Optional[trieste.models.gpflow.inducing_point_selectors.InducingPointSelector[SparseGaussianProcessRegression]] = None)

   Bases: :py:obj:`trieste.models.gpflow.interface.GPflowPredictor`, :py:obj:`trieste.models.interfaces.TrainableProbabilisticModel`, :py:obj:`trieste.models.gpflow.interface.SupportsCovarianceBetweenPoints`, :py:obj:`trieste.models.interfaces.SupportsGetInducingVariables`, :py:obj:`trieste.models.interfaces.SupportsGetInternalData`, :py:obj:`trieste.models.interfaces.HasTrajectorySampler`

   A :class:`TrainableProbabilisticModel` wrapper for a GPflow :class:`~gpflow.models.SGPR`.
   At the moment we only support models with a single latent GP. This is due to ``compute_qu``
   method in :class:`~gpflow.models.SGPR` that is used for computing covariance between
   query points and trajectory sampling, which at the moment works only for single latent GP.

   Similarly to our :class:`GaussianProcessRegression`, our :class:`~gpflow.models.SGPR` wrapper
   directly calls the posterior objects built by these models at prediction
   time. These posterior objects store the pre-computed Gram matrices, which can be reused to allow
   faster subsequent predictions. However, note that these posterior objects need to be updated
   whenever the underlying model is changed  by calling :meth:`update_posterior_cache` (this
   happens automatically after calls to :meth:`update` or :math:`optimize`).

   :param model: The GPflow model to wrap.
   :param optimizer: The optimizer with which to train the model. Defaults to
       :class:`~trieste.models.optimizer.Optimizer` with :class:`~gpflow.optimizers.Scipy`.
   :param num_rff_features: The number of random Fourier features used to approximate the
       kernel when calling :meth:`trajectory_sampler`. We use a default of 1000 as it
       typically perfoms well for a wide range of kernels. Note that very smooth
       kernels (e.g. RBF) can be well-approximated with fewer features.
   :param inducing_point_selector: The (optional) desired inducing point selector that
       will update the underlying GPflow SGPR model's inducing points as
       the optimization progresses.
   :raise NotImplementedError (or ValueError): If we try to use a model with invalid
       ``num_rff_features``, or an ``inducing_point_selector`` with a model
       that has more than one set of inducing points.

   .. py:method:: model(self) -> gpflow.models.SGPR
      :property:

      The underlying GPflow model.


   .. py:method:: predict_y(self, query_points: trieste.types.TensorType) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Return the mean and variance of the independent marginal distributions at each point in
      ``query_points`` for the observations, including noise contributions.

      Note that this is not supported by all models.

      :param query_points: The points at which to make predictions, of shape [..., D].
      :return: The mean and variance of the independent marginal distributions at each point in
          ``query_points``. For a predictive distribution with event shape E, the mean and
          variance will both have shape [...] + E.


   .. py:method:: optimize(self, dataset: trieste.data.Dataset) -> None

      Optimize the model with the specified `dataset`.

      :param dataset: The data with which to optimize the `model`.


   .. py:method:: update(self, dataset: trieste.data.Dataset) -> None

      Update the model given the specified ``dataset``. Does not train the model.

      :param dataset: The data with which to update the model.


   .. py:method:: _update_inducing_variables(self, new_inducing_points: trieste.types.TensorType) -> None

      When updating the inducing points of a model, we must also update the other
      inducing variables, i.e. `q_mu` and `q_sqrt` accordingly. The exact form of this update
      depends if we are using whitened representations of the inducing variables.
      See :meth:`_whiten_points` for details.

      :param new_inducing_points: The desired values for the new inducing points.
      :raise NotImplementedError: If we try to update the inducing variables of a model
          that has more than one set of inducing points.


   .. py:method:: get_inducing_variables(self) -> Tuple[Union[trieste.types.TensorType, list[trieste.types.TensorType]], trieste.types.TensorType, trieste.types.TensorType, bool]

      Return the model's inducing variables. The SGPR model does not have ``q_mu``, ``q_sqrt`` and
      ``whiten`` objects. We can use ``compute_qu`` method to obtain ``q_mu`` and ``q_sqrt``,
      while the SGPR model does not use the whitened representation. Note that at the moment
      ``compute_qu`` works only for single latent GP and returns ``q_sqrt`` in a shape that is
      inconsistent with the SVGP model (hence we need to do modify its shape).

      :return: The inducing points (i.e. locations of the inducing variables), as a Tensor or a
          list of Tensors (when the model has multiple inducing points); a tensor containing the
          variational mean ``q_mu``; a tensor containing the Cholesky decomposition of the
          variational covariance ``q_sqrt``; and a bool denoting if we are using whitened or
          non-whitened representations.
      :raise NotImplementedError: If the model has more than one latent GP.


   .. py:method:: covariance_between_points(self, query_points_1: trieste.types.TensorType, query_points_2: trieste.types.TensorType) -> trieste.types.TensorType

      Compute the posterior covariance between sets of query points.

      Note that query_points_2 must be a rank 2 tensor, but query_points_1 can
      have leading dimensions.

      :param query_points_1: Set of query points with shape [..., A, D]
      :param query_points_2: Sets of query points with shape [B, D]
      :return: Covariance matrix between the sets of query points with shape [..., L, A, B]
          (L being the number of latent GPs = number of output dimensions)


   .. py:method:: trajectory_sampler(self) -> trieste.models.interfaces.TrajectorySampler[SparseGaussianProcessRegression]

      Return a trajectory sampler. For :class:`SparseGaussianProcessRegression`, we build
      trajectories using a decoupled random Fourier feature approximation. Note that this
      is available only for single output models.

      At the moment only models with single latent GP are supported.

      :return: The trajectory sampler.
      :raise NotImplementedError: If we try to use the
          sampler with a model that has more than one latent GP.


   .. py:method:: get_internal_data(self) -> trieste.data.Dataset

      Return the model's training data.

      :return: The model's training data.



.. py:class:: SparseVariational(model: gpflow.models.SVGP, optimizer: Optimizer | None = None, num_rff_features: int = 1000, inducing_point_selector: Optional[trieste.models.gpflow.inducing_point_selectors.InducingPointSelector[SparseVariational]] = None)

   Bases: :py:obj:`trieste.models.gpflow.interface.GPflowPredictor`, :py:obj:`trieste.models.interfaces.TrainableProbabilisticModel`, :py:obj:`trieste.models.gpflow.interface.SupportsCovarianceBetweenPoints`, :py:obj:`trieste.models.interfaces.SupportsGetInducingVariables`, :py:obj:`trieste.models.interfaces.HasTrajectorySampler`

   A :class:`TrainableProbabilisticModel` wrapper for a GPflow :class:`~gpflow.models.SVGP`.

   Similarly to our :class:`GaussianProcessRegression`, our :class:`~gpflow.models.SVGP` wrapper
   directly calls the posterior objects built by these models at prediction
   time. These posterior objects store the pre-computed Gram matrices, which can be reused to allow
   faster subsequent predictions. However, note that these posterior objects need to be updated
   whenever the underlying model is changed  by calling :meth:`update_posterior_cache` (this
   happens automatically after calls to :meth:`update` or :math:`optimize`).

   :param model: The underlying GPflow sparse variational model.
   :param optimizer: The optimizer with which to train the model. Defaults to
       :class:`~trieste.models.optimizer.BatchOptimizer` with :class:`~tf.optimizers.Adam` with
       batch size 100.
   :param num_rff_features: The number of random Fourier features used to approximate the
       kernel when performing decoupled Thompson sampling through
       its :meth:`trajectory_sampler`. We use a default of 1000 as it typically
       perfoms well for a wide range of kernels. Note that very smooth kernels (e.g. RBF)
       can be well-approximated with fewer features.
   :param inducing_point_selector: The (optional) desired inducing_point_selector that
       will update the underlying GPflow sparse variational model's inducing points as
       the optimization progresses.
   :raise NotImplementedError: If we try to use an inducing_point_selector with a model
       that has more than one set of inducing points.

   .. py:method:: model(self) -> gpflow.models.SVGP
      :property:

      The underlying GPflow model.


   .. py:method:: predict_y(self, query_points: trieste.types.TensorType) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Return the mean and variance of the independent marginal distributions at each point in
      ``query_points`` for the observations, including noise contributions.

      Note that this is not supported by all models.

      :param query_points: The points at which to make predictions, of shape [..., D].
      :return: The mean and variance of the independent marginal distributions at each point in
          ``query_points``. For a predictive distribution with event shape E, the mean and
          variance will both have shape [...] + E.


   .. py:method:: update(self, dataset: trieste.data.Dataset) -> None

      Update the model given the specified ``dataset``. Does not train the model.

      :param dataset: The data with which to update the model.


   .. py:method:: optimize(self, dataset: trieste.data.Dataset) -> None

      Optimize the model with the specified `dataset`.

      :param dataset: The data with which to optimize the `model`.


   .. py:method:: _update_inducing_variables(self, new_inducing_points: trieste.types.TensorType) -> None

      When updating the inducing points of a model, we must also update the other
      inducing variables, i.e. `q_mu` and `q_sqrt` accordingly. The exact form of this update
      depends if we are using whitened representations of the inducing variables.
      See :meth:`_whiten_points` for details.

      :param new_inducing_points: The desired values for the new inducing points.
      :raise NotImplementedError: If we try to update the inducing variables of a model
          that has more than one set of inducing points.


   .. py:method:: get_inducing_variables(self) -> Tuple[Union[trieste.types.TensorType, list[trieste.types.TensorType]], trieste.types.TensorType, trieste.types.TensorType, bool]

      Return the model's inducing variables.

      :return: The inducing points (i.e. locations of the inducing variables), as a Tensor or a
          list of Tensors (when the model has multiple inducing points); A tensor containing the
          variational mean q_mu; a tensor containing the Cholesky decomposition of the variational
          covariance q_sqrt; and a bool denoting if we are using whitened or
          non-whitened representations.


   .. py:method:: covariance_between_points(self, query_points_1: trieste.types.TensorType, query_points_2: trieste.types.TensorType) -> trieste.types.TensorType

      Compute the posterior covariance between sets of query points.

      Note that query_points_2 must be a rank 2 tensor, but query_points_1 can
      have leading dimensions.

      :param query_points_1: Set of query points with shape [..., A, D]
      :param query_points_2: Sets of query points with shape [B, D]
      :return: Covariance matrix between the sets of query points with shape [..., L, A, B]
          (L being the number of latent GPs = number of output dimensions)


   .. py:method:: trajectory_sampler(self) -> trieste.models.interfaces.TrajectorySampler[SparseVariational]

      Return a trajectory sampler. For :class:`SparseVariational`, we build
      trajectories using a decoupled random Fourier feature approximation.

      At the moment only models with single latent GP are supported.

      :return: The trajectory sampler.
      :raise NotImplementedError: If we try to use the
          sampler with a model that has more than one latent GP.



.. py:class:: VariationalGaussianProcess(model: gpflow.models.VGP, optimizer: Optimizer | None = None, use_natgrads: bool = False, natgrad_gamma: Optional[float] = None, num_rff_features: int = 1000)

   Bases: :py:obj:`trieste.models.gpflow.interface.GPflowPredictor`, :py:obj:`trieste.models.interfaces.TrainableProbabilisticModel`, :py:obj:`trieste.models.gpflow.interface.SupportsCovarianceBetweenPoints`, :py:obj:`trieste.models.interfaces.SupportsGetInducingVariables`, :py:obj:`trieste.models.interfaces.HasTrajectorySampler`

   A :class:`TrainableProbabilisticModel` wrapper for a GPflow :class:`~gpflow.models.VGP`.

   A Variational Gaussian Process (VGP) approximates the posterior of a GP
   using the multivariate Gaussian closest to the posterior of the GP by minimizing the
   KL divergence between approximated and exact posteriors. See :cite:`opper2009variational`
   for details.

   The VGP provides (approximate) GP modelling under non-Gaussian likelihoods, for example
   when fitting a classification model over binary data.

   A whitened representation and (optional) natural gradient steps are used to aid
   model optimization.

   Similarly to our :class:`GaussianProcessRegression`, our :class:`~gpflow.models.VGP` wrapper
   directly calls the posterior objects built by these models at prediction
   time. These posterior objects store the pre-computed Gram matrices, which can be reused to allow
   faster subsequent predictions. However, note that these posterior objects need to be updated
   whenever the underlying model is changed  by calling :meth:`update_posterior_cache` (this
   happens automatically after calls to :meth:`update` or :math:`optimize`).

   :param model: The GPflow :class:`~gpflow.models.VGP`.
   :param optimizer: The optimizer with which to train the model. Defaults to
       :class:`~trieste.models.optimizer.Optimizer` with :class:`~gpflow.optimizers.Scipy`.
   :param use_natgrads: If True then alternate model optimization steps with natural
       gradient updates. Note that natural gradients requires
       a :class:`~trieste.models.optimizer.BatchOptimizer` wrapper with
       :class:`~tf.optimizers.Optimizer` optimizer.
   :natgrad_gamma: Gamma parameter for the natural gradient optimizer.
   :param num_rff_features: The number of random Fourier features used to approximate the
       kernel when performing decoupled Thompson sampling through
       its :meth:`trajectory_sampler`. We use a default of 1000 as it typically perfoms
       well for a wide range of kernels. Note that very smooth kernels (e.g. RBF) can
       be well-approximated with fewer features.
   :raise ValueError (or InvalidArgumentError): If ``model``'s :attr:`q_sqrt` is not rank 3
       or if attempting to combine natural gradients with a :class:`~gpflow.optimizers.Scipy`
       optimizer.

   .. py:method:: model(self) -> gpflow.models.VGP
      :property:

      The underlying GPflow model.


   .. py:method:: predict_y(self, query_points: trieste.types.TensorType) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Return the mean and variance of the independent marginal distributions at each point in
      ``query_points`` for the observations, including noise contributions.

      Note that this is not supported by all models.

      :param query_points: The points at which to make predictions, of shape [..., D].
      :return: The mean and variance of the independent marginal distributions at each point in
          ``query_points``. For a predictive distribution with event shape E, the mean and
          variance will both have shape [...] + E.


   .. py:method:: update(self, dataset: trieste.data.Dataset, *, jitter: float = DEFAULTS.JITTER) -> None

      Update the model given the specified ``dataset``. Does not train the model.

      :param dataset: The data with which to update the model.
      :param jitter: The size of the jitter to use when stabilizing the Cholesky decomposition of
          the covariance matrix.


   .. py:method:: optimize(self, dataset: trieste.data.Dataset) -> None

      :class:`VariationalGaussianProcess` has a custom `optimize` method that (optionally) permits
      alternating between standard optimization steps (for kernel parameters) and natural gradient
      steps for the variational parameters (`q_mu` and `q_sqrt`). See :cite:`salimbeni2018natural`
      for details. Using natural gradients can dramatically speed up model fitting, especially for
      ill-conditioned posteriors.

      If using natural gradients, our optimizer inherits the mini-batch behavior and number
      of optimization steps as the base optimizer specified when initializing
      the :class:`VariationalGaussianProcess`.


   .. py:method:: get_inducing_variables(self) -> Tuple[trieste.types.TensorType, trieste.types.TensorType, trieste.types.TensorType, bool]

      Return the model's inducing variables. Note that GPflow's VGP model is
      hard-coded to use the whitened representation.

      :return: Tensors containing: the inducing points (i.e. locations of the inducing
          variables); the variational mean q_mu; the Cholesky decomposition of the
          variational covariance q_sqrt; and a bool denoting if we are using whitened
          or non-whitened representations.


   .. py:method:: trajectory_sampler(self) -> trieste.models.interfaces.TrajectorySampler[VariationalGaussianProcess]

      Return a trajectory sampler. For :class:`VariationalGaussianProcess`, we build
      trajectories using a decoupled random Fourier feature approximation.

      At the moment only models with single latent GP are supported.

      :return: The trajectory sampler.
      :raise NotImplementedError: If we try to use the
          sampler with a model that has more than one latent GP.


   .. py:method:: covariance_between_points(self, query_points_1: trieste.types.TensorType, query_points_2: trieste.types.TensorType) -> trieste.types.TensorType

      Compute the posterior covariance between sets of query points.

      Note that query_points_2 must be a rank 2 tensor, but query_points_1 can
      have leading dimensions.

      :param query_points_1: Set of query points with shape [..., A, D]
      :param query_points_2: Sets of query points with shape [B, D]
      :return: Covariance matrix between the sets of query points with shape [..., L, A, B]
          (L being the number of latent GPs = number of output dimensions)



.. py:class:: BatchReparametrizationSampler(sample_size: int, model: trieste.models.interfaces.SupportsPredictJoint)

   Bases: :py:obj:`trieste.models.interfaces.ReparametrizationSampler`\ [\ :py:obj:`trieste.models.interfaces.SupportsPredictJoint`\ ]

   This sampler employs the *reparameterization trick* to approximate batches of samples from a
   :class:`ProbabilisticModel`\ 's predictive joint distribution as

   .. math:: x \mapsto \mu(x) + \epsilon L(x)

   where :math:`L` is the Cholesky factor s.t. :math:`LL^T` is the covariance, and
   :math:`\epsilon \sim \mathcal N (0, 1)` is constant for a given sampler, thus ensuring samples
   form a continuous curve.

   :param sample_size: The number of samples for each batch of points. Must be positive.
   :param model: The model to sample from.
   :raise ValueError (or InvalidArgumentError): If ``sample_size`` is not positive.

   .. py:method:: sample(self, at: trieste.types.TensorType, *, jitter: float = DEFAULTS.JITTER) -> trieste.types.TensorType

      Return approximate samples from the `model` specified at :meth:`__init__`. Multiple calls to
      :meth:`sample`, for any given :class:`BatchReparametrizationSampler` and ``at``, will
      produce the exact same samples. Calls to :meth:`sample` on *different*
      :class:`BatchReparametrizationSampler` instances will produce different samples.

      :param at: Batches of query points at which to sample the predictive distribution, with
          shape `[..., B, D]`, for batches of size `B` of points of dimension `D`. Must have a
          consistent batch size across all calls to :meth:`sample` for any given
          :class:`BatchReparametrizationSampler`.
      :param jitter: The size of the jitter to use when stabilising the Cholesky decomposition of
          the covariance matrix.
      :return: The samples, of shape `[..., S, B, L]`, where `S` is the `sample_size`, `B` the
          number of points per batch, and `L` the dimension of the model's predictive
          distribution.
      :raise ValueError (or InvalidArgumentError): If any of the following are true:
          - ``at`` is a scalar.
          - The batch size `B` of ``at`` is not positive.
          - The batch size `B` of ``at`` differs from that of previous calls.
          - ``jitter`` is negative.



.. py:class:: DecoupledTrajectorySampler(model: Union[FeatureDecompositionInducingPointModel, FeatureDecompositionInternalDataModel], num_features: int = 1000)

   Bases: :py:obj:`FeatureDecompositionTrajectorySampler`\ [\ :py:obj:`Union`\ [\ :py:obj:`FeatureDecompositionInducingPointModel`\ , :py:obj:`FeatureDecompositionInternalDataModel`\ ]\ ]

   This class builds functions that approximate a trajectory sampled from an underlying Gaussian
   process model using decoupled sampling. See :cite:`wilson2020efficiently` for an introduction
   to decoupled sampling. Currently we do not support models with multiple latent Gaussian
   processes.

   Unlike our :class:`RandomFourierFeatureTrajectorySampler` which uses a RFF decomposition to
   aprroximate the Gaussian process posterior, a :class:`DecoupledTrajectorySampler` only
   uses an RFF decomposition to approximate the Gausian process prior and instead using
   a cannonical decomposition to discretize the effect of updating the prior on the given data.

   In particular, we approximate the Gaussian processes' posterior samples as the finite feature
   approximation

   .. math:: \hat{f}(.) = \sum_{i=1}^L w_i\phi_i(.) + \sum_{j=1}^m v_jk(.,z_j)

   where :math:`\phi_i(.)` and :math:`w_i` are the Fourier features and their weights that
   discretize the prior. In contrast, `k(.,z_j)` and :math:`v_i` are the cannonical features and
   their weights that discretize the data update.

   The expression for :math:`v_i` depends on if we are using an exact Gaussian process or a sparse
   approximations. See  eq. (13) in :cite:`wilson2020efficiently` for details.

   Note that if a model is both of :class:`FeatureDecompositionInducingPointModel` type and
   :class:`FeatureDecompositionInternalDataModel` type,
   :class:`FeatureDecompositionInducingPointModel` will take a priority and inducing points
   will be used for computations rather than data.

   :param model: The model to sample from.
   :param num_features: The number of features used to approximate the kernel. We use a default
       of 1000 as it typically perfoms well for a wide range of kernels. Note that very smooth
       kernels (e.g. RBF) can be well-approximated with fewer features.
   :raise NotImplementedError: If the model is not of valid type.

   .. py:method:: _prepare_weight_sampler(self) -> Callable[[int], trieste.types.TensorType]

      Prepare the sampler function that provides samples of the feature weights
      for both the RFF and cannonical feature functions, i.e. we return a function
      that takes in a batch size `B` and returns `B` samples for the weights of each of
      the `L`  RFF features and `N` cannonical features.



.. py:class:: IndependentReparametrizationSampler(sample_size: int, model: trieste.models.interfaces.ProbabilisticModel)

   Bases: :py:obj:`trieste.models.interfaces.ReparametrizationSampler`\ [\ :py:obj:`trieste.models.interfaces.ProbabilisticModel`\ ]

   This sampler employs the *reparameterization trick* to approximate samples from a
   :class:`ProbabilisticModel`\ 's predictive distribution as

   .. math:: x \mapsto \mu(x) + \epsilon \sigma(x)

   where :math:`\epsilon \sim \mathcal N (0, 1)` is constant for a given sampler, thus ensuring
   samples form a continuous curve.

   :param sample_size: The number of samples to take at each point. Must be positive.
   :param model: The model to sample from.
   :raise ValueError (or InvalidArgumentError): If ``sample_size`` is not positive.

   .. py:method:: sample(self, at: trieste.types.TensorType, *, jitter: float = DEFAULTS.JITTER) -> trieste.types.TensorType

      Return approximate samples from the `model` specified at :meth:`__init__`. Multiple calls to
      :meth:`sample`, for any given :class:`IndependentReparametrizationSampler` and ``at``, will
      produce the exact same samples. Calls to :meth:`sample` on *different*
      :class:`IndependentReparametrizationSampler` instances will produce different samples.

      :param at: Where to sample the predictive distribution, with shape `[..., 1, D]`, for points
          of dimension `D`.
      :param jitter: The size of the jitter to use when stabilising the Cholesky decomposition of
          the covariance matrix.
      :return: The samples, of shape `[..., S, 1, L]`, where `S` is the `sample_size` and `L` is
          the number of latent model dimensions.
      :raise ValueError (or InvalidArgumentError): If ``at`` has an invalid shape or ``jitter``
          is negative.



.. py:class:: RandomFourierFeatureTrajectorySampler(model: FeatureDecompositionInternalDataModel, num_features: int = 1000)

   Bases: :py:obj:`FeatureDecompositionTrajectorySampler`\ [\ :py:obj:`FeatureDecompositionInternalDataModel`\ ]

   This class builds functions that approximate a trajectory sampled from an underlying Gaussian
   process model. For tractibility, the Gaussian process is approximated with a Bayesian
   Linear model across a set of features sampled from the Fourier feature decomposition of
   the model's kernel. See :cite:`hernandez2014predictive` for details. Currently we do not
   support models with multiple latent Gaussian processes.

   In particular, we approximate the Gaussian processes' posterior samples as the finite feature
   approximation

   .. math:: \hat{f}(x) = \sum_{i=1}^m \phi_i(x)\theta_i

   where :math:`\phi_i` are m Fourier features and :math:`\theta_i` are
   feature weights sampled from a posterior distribution that depends on the feature values at the
   model's datapoints.

   Our implementation follows :cite:`hernandez2014predictive`, with our calculations
   differing slightly depending on properties of the problem. In particular,  we used different
   calculation strategies depending on the number of considered features m and the number
   of data points n.

   If :math:`m<n` then we follow Appendix A of :cite:`hernandez2014predictive` and calculate the
   posterior distribution for :math:`\theta` following their Bayesian linear regression motivation,
   i.e. the computation revolves around an O(m^3)  inversion of a design matrix.

   If :math:`n<m` then we use the kernel trick to recast computation to revolve around an O(n^3)
   inversion of a gram matrix. As well as being more efficient in early BO
   steps (where :math:`n<m`), this second computation method allows much larger choices
   of m (as required to approximate very flexible kernels).

   :param model: The model to sample from.
   :param num_features: The number of features used to approximate the kernel. We use a default
       of 1000 as it typically perfoms well for a wide range of kernels. Note that very smooth
       kernels (e.g. RBF) can be well-approximated with fewer features.
   :raise ValueError: If ``dataset`` is empty.

   .. py:method:: _prepare_weight_sampler(self) -> Callable[[int], trieste.types.TensorType]

      Calculate the posterior of theta (the feature weights) for the RFFs, returning
      a function that takes in a batch size `B` and returns `B` samples for
      the weights of each of the RFF `L` features.


   .. py:method:: _prepare_theta_posterior_in_design_space(self) -> tensorflow_probability.distributions.MultivariateNormalTriL

      Calculate the posterior of theta (the feature weights) in the design space. This
      distribution is a Gaussian

      .. math:: \theta \sim N(D^{-1}\Phi^Ty,D^{-1}\sigma^2)

      where the [m,m] design matrix :math:`D=(\Phi^T\Phi + \sigma^2I_m)` is defined for
      the [n,m] matrix of feature evaluations across the training data :math:`\Phi`
      and observation noise variance :math:`\sigma^2`.


   .. py:method:: _prepare_theta_posterior_in_gram_space(self) -> tensorflow_probability.distributions.MultivariateNormalTriL

      Calculate the posterior of theta (the feature weights) in the gram space.

       .. math:: \theta \sim N(\Phi^TG^{-1}y,I_m - \Phi^TG^{-1}\Phi)

      where the [n,n] gram matrix :math:`G=(\Phi\Phi^T + \sigma^2I_n)` is defined for the [n,m]
      matrix of feature evaluations across the training data :math:`\Phi` and
      observation noise variance :math:`\sigma^2`.



.. py:class:: feature_decomposition_trajectory(feature_functions: Callable[[trieste.types.TensorType], trieste.types.TensorType], weight_sampler: Callable[[int], trieste.types.TensorType], mean_function: Callable[[trieste.types.TensorType], trieste.types.TensorType])

   Bases: :py:obj:`trieste.models.interfaces.TrajectoryFunctionClass`

   An approximate sample from a Gaussian processes' posterior samples represented as a
   finite weighted sum of features.

   A trajectory is given by

   .. math:: \hat{f}(x) = \sum_{i=1}^m \phi_i(x)\theta_i

   where :math:`\phi_i` are m feature functions and :math:`\theta_i` are
   feature weights sampled from a posterior distribution.

   The number of trajectories (i.e. batch size) is determined from the first call of the
   trajectory. In order to change the batch size, a new :class:`TrajectoryFunction` must be built.

   :param feature_functions: Set of feature function.
   :param weight_sampler: New sampler that generates feature weight samples.
   :param mean_function: The underlying model's mean function.

   .. py:method:: __call__(self, x: trieste.types.TensorType) -> trieste.types.TensorType

      Call trajectory function.


   .. py:method:: resample(self) -> None

      Efficiently resample in-place without retracing.


   .. py:method:: update(self, weight_sampler: Callable[[int], trieste.types.TensorType]) -> None

      Efficiently update the trajectory with a new weight distribution and resample its weights.

      :param weight_sampler: New sampler that generates feature weight samples.



.. py:function:: assert_data_is_compatible(new_data: trieste.data.Dataset, existing_data: trieste.data.Dataset) -> None

   Checks that new data is compatible with existing data.

   :param new_data: New data.
   :param existing_data: Existing data.
   :raise ValueError: if trailing dimensions of the query point or observation differ.


.. py:function:: check_optimizer(optimizer: Union[trieste.models.optimizer.BatchOptimizer, trieste.models.optimizer.Optimizer]) -> None

   Check that the optimizer for the GPflow models is using a correct optimizer wrapper.

   Stochastic gradient descent based methods implemented in TensorFlow would not
   work properly without mini-batches and hence :class:`~trieste.models.optimizers.BatchOptimizer`
   that prepares mini-batches and calls the optimizer iteratively needs to be used. GPflow's
   :class:`~gpflow.optimizers.Scipy` optimizer on the other hand should use the non-batch wrapper
   :class:`~trieste.models.optimizers.Optimizer`.

   :param optimizer: An instance of the optimizer wrapper with the underlying optimizer.
   :raise ValueError: If :class:`~tf.optimizers.Optimizer` is not using
       :class:`~trieste.models.optimizers.BatchOptimizer` or :class:`~gpflow.optimizers.Scipy` is
       using :class:`~trieste.models.optimizers.BatchOptimizer`.


.. py:function:: randomize_hyperparameters(object: gpflow.Module) -> None

   Sets hyperparameters to random samples from their constrained domains or (if not constraints
   are available) their prior distributions.

   :param object: Any gpflow Module.


.. py:function:: squeeze_hyperparameters(object: gpflow.Module, alpha: float = 0.01, epsilon: float = 1e-07) -> None

   Squeezes the parameters to be strictly inside their range defined by the Sigmoid,
   or strictly greater than the limit defined by the Shift+Softplus.
   This avoids having Inf unconstrained values when the parameters are exactly at the boundary.

   :param object: Any gpflow Module.
   :param alpha: the proportion of the range with which to squeeze for the Sigmoid case
   :param epsilon: the value with which to offset the shift for the Softplus case.
   :raise ValueError: If ``alpha`` is not in (0,1) or epsilon <= 0


