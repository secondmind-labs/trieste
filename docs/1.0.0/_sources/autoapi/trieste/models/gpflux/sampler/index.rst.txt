:orphan:

:py:mod:`trieste.models.gpflux.sampler`
=======================================

.. py:module:: trieste.models.gpflux.sampler


Module Contents
---------------

.. py:class:: DeepGaussianProcessReparamSampler(sample_size: int, model: trieste.models.gpflux.interface.GPfluxPredictor)

   Bases: :py:obj:`trieste.models.interfaces.ReparametrizationSampler`\ [\ :py:obj:`trieste.models.gpflux.interface.GPfluxPredictor`\ ]

   This sampler employs the *reparameterization trick* to approximate samples from a
   :class:`GPfluxPredictor`\ 's predictive distribution, when the :class:`GPfluxPredictor` has
   an underlying :class:`~gpflux.models.DeepGP`.

   :param sample_size: The number of samples for each batch of points. Must be positive.
   :param model: The model to sample from.
   :raise ValueError (or InvalidArgumentError): If ``sample_size`` is not positive, if the
       model is not a :class:`GPfluxPredictor`, of if its underlying ``model_gpflux`` is not a
       :class:`~gpflux.models.DeepGP`.

   .. py:method:: sample(at: trieste.types.TensorType, *, jitter: float = DEFAULTS.JITTER) -> trieste.types.TensorType

      Return approximate samples from the `model` specified at :meth:`__init__`. Multiple calls to
      :meth:`sample`, for any given :class:`DeepGaussianProcessReparamSampler` and ``at``, will
      produce the exact same samples. Calls to :meth:`sample` on *different*
      :class:`DeepGaussianProcessReparamSampler` instances will produce different samples.

      :param at: Where to sample the predictive distribution, with shape `[..., 1, D]`, for points
          of dimension `D`.
      :param jitter: The size of the jitter to use when stabilizing the Cholesky
          decomposition of the covariance matrix.
      :return: The samples, of shape `[..., S, 1, L]`, where `S` is the `sample_size` and `L` is
          the number of latent model dimensions.
      :raise ValueError (or InvalidArgumentError): If ``at`` has an invalid shape or ``jitter``
          is negative.



.. py:class:: DeepGaussianProcessDecoupledTrajectorySampler(model: trieste.models.gpflux.interface.GPfluxPredictor, num_features: int = 1000)

   Bases: :py:obj:`trieste.models.interfaces.TrajectorySampler`\ [\ :py:obj:`trieste.models.gpflux.interface.GPfluxPredictor`\ ]

   This sampler employs decoupled sampling (see :cite:`wilson2020efficiently`) to build functions
   that approximate a trajectory sampled from an underlying deep Gaussian process model. In
   particular, this sampler provides trajectory functions for :class:`GPfluxPredictor`\s with
   underlying :class:`~gpflux.models.DeepGP` models by using a feature decomposition using both
   random Fourier features and canonical features centered at inducing point locations. This allows
   for cheap approximate trajectory samples, as opposed to exact trajectory sampling, which scales
   cubically in the number of query points.

   :param model: The model to sample from.
   :param num_features: The number of random Fourier features to use.
   :raise ValueError (or InvalidArgumentError): If the model is not a :class:`GPfluxPredictor`,
       or its underlying ``model_gpflux`` is not a :class:`~gpflux.models.DeepGP`, or
       ``num_features`` is not positive.

   .. py:method:: get_trajectory() -> trieste.models.interfaces.TrajectoryFunction

      Generate an approximate function draw (trajectory) from the deep GP model.

      :return: A trajectory function representing an approximate trajectory from the deep GP,
          taking an input of shape `[N, B, D]` and returning shape `[N, B, L]`.


   .. py:method:: update_trajectory(trajectory: trieste.models.interfaces.TrajectoryFunction) -> trieste.models.interfaces.TrajectoryFunction

      Efficiently update a :const:`TrajectoryFunction` to reflect an update in its underlying
      :class:`ProbabilisticModel` and resample accordingly.

      :param trajectory: The trajectory function to be updated and resampled.
      :return: The updated and resampled trajectory function.
      :raise InvalidArgumentError: If ``trajectory`` is not a
          :class:`dgp_feature_decomposition_trajectory`


   .. py:method:: resample_trajectory(trajectory: trieste.models.interfaces.TrajectoryFunction) -> trieste.models.interfaces.TrajectoryFunction

      Efficiently resample a :const:`TrajectoryFunction` in-place to avoid function retracing
      with every new sample.

      :param trajectory: The trajectory function to be resampled.
      :return: The new resampled trajectory function.
      :raise InvalidArgumentError: If ``trajectory`` is not a
          :class:`dgp_feature_decomposition_trajectory`



.. py:class:: DeepGaussianProcessDecoupledLayer(model: trieste.models.gpflux.interface.GPfluxPredictor, layer_number: int, num_features: int = 1000)

   Bases: :py:obj:`abc.ABC`

   Layer that samples an approximate decoupled trajectory for a GPflux
   :class:`~gpflux.layers.GPLayer` using Matheron's rule (:cite:`wilson2020efficiently`). Note
   that the only multi-output kernel that is supported is a
   :class:`~gpflow.kernels.SharedIndependent` kernel.

   :param model: The model to sample from.
   :param layer_number: The index of the layer that we wish to sample from.
   :param num_features: The number of features to use in the random feature approximation.
   :raise ValueError (or InvalidArgumentError): If the layer is not a
       :class:`~gpflux.layers.GPLayer`, the layer's kernel is not supported, or if
       ``num_features`` is not positive.

   .. py:method:: __call__(x: trieste.types.TensorType) -> trieste.types.TensorType

      Evaluate trajectory function for layer at input.

      :param x: Input location with shape `[N, B, D]`, where `N` is the number of points, `B` is
          the batch dimension, and `D` is the input dimensionality.
      :return: Trajectory for the layer evaluated at the input, with shape `[N, B, P]`, where `P`
          is the number of latent GPs in the layer.
      :raise InvalidArgumentError: If the provided batch size does not match with the layer's
          batch size.


   .. py:method:: resample() -> None

      Efficiently resample in-place without retracing.


   .. py:method:: update() -> None

      Efficiently update the trajectory with a new weight distribution and resample its weights.


   .. py:method:: _prepare_weight_sampler() -> Callable[[int], trieste.types.TensorType]

      Prepare the sampler function that provides samples of the feature weights for both the
      RFF and canonical feature functions, i.e. we return a function that takes in a batch size
      `B` and returns `B` samples for the weights of each of the `L` RFF features and `M`
      canonical features for `P` outputs.



.. py:class:: ResampleableDecoupledDeepGaussianProcessFeatureFunctions(layer: gpflux.layers.GPLayer, n_components: int)

   Bases: :py:obj:`gpflux.layers.basis_functions.fourier_features.RandomFourierFeaturesCosine`

   A wrapper around GPflux's random Fourier feature function that allows for efficient in-place
   updating when generating new decompositions. In addition to providing Fourier features,
   this class concatenates a layer's Fourier feature expansion with evaluations of the canonical
   basis functions.

   :param layer: The layer that will be approximated by the feature functions.
   :param n_components: The number of features.
   :raise ValueError: If the layer is not a :class:`~gpflux.layers.GPLayer`.

   .. py:method:: resample() -> None

      Resample weights and biases.


   .. py:method:: __call__(x: trieste.types.TensorType) -> trieste.types.TensorType

      Evaluate and combine prior basis functions and canonical basic functions at the input.



.. py:class:: dgp_feature_decomposition_trajectory(model: trieste.models.gpflux.interface.GPfluxPredictor, num_features: int)

   Bases: :py:obj:`trieste.models.interfaces.TrajectoryFunctionClass`

   An approximate sample from a deep Gaussian process's posterior, where the samples are
   represented as a finite weighted sum of features. This class essentially takes a list of
   :class:`DeepGaussianProcessDecoupledLayer`\s and iterates through them to sample, update and
   resample.

   :param model: The model to sample from.
   :param num_features: The number of random Fourier features to use.

   .. py:method:: __call__(x: trieste.types.TensorType) -> trieste.types.TensorType

      Call trajectory function by looping through layers.

      :param x: Input location with shape `[N, B, D]`, where `N` is the number of points, `B` is
          the batch dimension, and `D` is the input dimensionality.
      :return: Trajectory samples with shape `[N, B, L]`, where `L` is the number of outputs.


   .. py:method:: update() -> None

      Update the layers with new features and weights.


   .. py:method:: resample() -> None

      Resample the layer weights.



