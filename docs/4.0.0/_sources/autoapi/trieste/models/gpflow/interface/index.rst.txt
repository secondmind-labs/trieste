:orphan:

:py:mod:`trieste.models.gpflow.interface`
=========================================

.. py:module:: trieste.models.gpflow.interface


Module Contents
---------------

.. py:class:: GPflowPredictor(optimizer: trieste.models.optimizer.Optimizer | None = None, encoder: trieste.space.EncoderFunction | None = None)


   Bases: :py:obj:`trieste.models.interfaces.EncodedSupportsPredictJoint`, :py:obj:`trieste.models.interfaces.SupportsGetKernel`, :py:obj:`trieste.models.interfaces.SupportsGetObservationNoise`, :py:obj:`trieste.models.interfaces.EncodedSupportsPredictY`, :py:obj:`trieste.models.interfaces.HasReparamSampler`, :py:obj:`trieste.models.interfaces.EncodedTrainableProbabilisticModel`, :py:obj:`trieste.models.interfaces.EncodedProbabilisticModel`, :py:obj:`abc.ABC`

   A trainable wrapper for a GPflow Gaussian process model.

   :param optimizer: The optimizer with which to train the model. Defaults to
       :class:`~trieste.models.optimizer.Optimizer` with :class:`~gpflow.optimizers.Scipy`.
   :param encoder: Optional encoder with which to transform query points before
       generating predictions.

   .. py:property:: encoder
      :type: trieste.space.EncoderFunction | None

      Query point encoder.


   .. py:property:: optimizer
      :type: trieste.models.optimizer.Optimizer

      The optimizer with which to train the model.


   .. py:property:: model
      :type: gpflow.models.GPModel
      :abstractmethod:

      The underlying GPflow model.


   .. py:method:: create_posterior_cache() -> None

      Create a posterior cache for fast sequential predictions.  Note that this must happen
      at initialisation and *after* we ensure the model data is variable. Furthermore,
      the cache must be updated whenever the underlying model is changed.


   .. py:method:: _ensure_variable_model_data() -> None

      Ensure GPflow data, which is normally stored in Tensors, is instead stored in
      dynamically shaped Variables. Override this as required.


   .. py:method:: update_posterior_cache() -> None

      Update the posterior cache. This needs to be called whenever the underlying model
      is changed.


   .. py:method:: predict_encoded(query_points: trieste.types.TensorType) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Implementation of predict on encoded query points.


   .. py:method:: predict_joint_encoded(query_points: trieste.types.TensorType) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Implementation of predict_joint on encoded query points.


   .. py:method:: sample_encoded(query_points: trieste.types.TensorType, num_samples: int) -> trieste.types.TensorType

      Implementation of sample on encoded query points.


   .. py:method:: predict_y_encoded(query_points: trieste.types.TensorType) -> tuple[trieste.types.TensorType, trieste.types.TensorType]

      Implementation of predict_y on encoded query points.


   .. py:method:: get_kernel() -> gpflow.kernels.Kernel

      Return the kernel of the model.

      :return: The kernel.


   .. py:method:: get_mean_function() -> gpflow.mean_functions.MeanFunction

      Return the mean function of the model.

      :return: The mean function.


   .. py:method:: get_observation_noise() -> trieste.types.TensorType

      Return the variance of observation noise for homoscedastic likelihoods.

      :return: The observation noise.
      :raise NotImplementedError: If the model does not have a homoscedastic likelihood.


   .. py:method:: log(dataset: Optional[trieste.data.Dataset] = None) -> None

      Log model training information at a given optimization step to the Tensorboard.
      We log kernel and likelihood parameters. We also log several training data based metrics,
      such as root mean square error between predictions and observations and several others.

      :param dataset: Optional data that can be used to log additional data-based model summaries.


   .. py:method:: reparam_sampler(num_samples: int) -> trieste.models.interfaces.ReparametrizationSampler[GPflowPredictor]

      Return a reparametrization sampler providing `num_samples` samples.

      :return: The reparametrization sampler.



.. py:class:: SupportsCovarianceBetweenPoints


   Bases: :py:obj:`trieste.models.interfaces.SupportsPredictJoint`, :py:obj:`typing_extensions.Protocol`

   A probabilistic model that supports covariance_between_points.

   .. py:method:: covariance_between_points(query_points_1: trieste.types.TensorType, query_points_2: trieste.types.TensorType) -> trieste.types.TensorType
      :abstractmethod:

      Compute the posterior covariance between sets of query points.

      .. math:: \Sigma_{12} = K_{12} - K_{x1}(K_{xx} + \sigma^2 I)^{-1}K_{x2}

      Note that query_points_2 must be a rank 2 tensor, but query_points_1 can
      have leading dimensions.

      :param query_points_1: Set of query points with shape [..., N, D]
      :param query_points_2: Sets of query points with shape [M, D]
      :return: Covariance matrix between the sets of query points with shape [..., L, N, M]
          (L being the number of latent GPs = number of output dimensions)



.. py:class:: EncodedSupportsCovarianceBetweenPoints


   Bases: :py:obj:`trieste.models.interfaces.EncodedProbabilisticModel`, :py:obj:`SupportsCovarianceBetweenPoints`

   A probabilistic model with an associated query point encoder.

   Classes that inherit from this (or the other associated mixins below) should implement the
   relevant _encoded methods (e.g. predict_encoded instead of predict), to which the public
   methods delegate after encoding their input. Take care to use the correct methods internally
   to avoid encoding twice accidentally.

   .. py:method:: covariance_between_points_encoded(query_points_1: trieste.types.TensorType, query_points_2: trieste.types.TensorType) -> trieste.types.TensorType
      :abstractmethod:

      Implementation of covariance_between_points on encoded query points.


   .. py:method:: covariance_between_points(query_points_1: trieste.types.TensorType, query_points_2: trieste.types.TensorType) -> trieste.types.TensorType

      Compute the posterior covariance between sets of query points.

      .. math:: \Sigma_{12} = K_{12} - K_{x1}(K_{xx} + \sigma^2 I)^{-1}K_{x2}

      Note that query_points_2 must be a rank 2 tensor, but query_points_1 can
      have leading dimensions.

      :param query_points_1: Set of query points with shape [..., N, D]
      :param query_points_2: Sets of query points with shape [M, D]
      :return: Covariance matrix between the sets of query points with shape [..., L, N, M]
          (L being the number of latent GPs = number of output dimensions)



